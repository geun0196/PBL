24-2 신종 바이러스인 웜 바이러스는 네트워크를 통해 전파된다. 한 컴퓨터가 웜 바이러스에 걸리면 그 컴퓨터와 네트워크 상에서 연결되어 있는 모든 컴퓨터는 웜 바이러스에 걸리게 된다. 예를 들어 7대의 컴퓨터가 <그림 1>과 같이 네트워크 상에서 연결되어 있다고 하자. 1번 컴퓨터가 웜 바이러스에 걸리면 웜 바이러스는 2번과 5번 컴퓨터를 거쳐 3번과 6번 컴퓨터까지 전파되어 2, 3, 5, 6 네 대의 컴퓨터는 웜 바이러스에 걸리게 된다. 하지만 4번과 7번 컴퓨터는 1번 컴퓨터와 네트워크상에서 연결되어 있지 않기 때문에 영향을 받지 않는다. 어느 날 1번 컴퓨터가 웜 바이러스에 걸렸다. 컴퓨터의 수와 네트워크 상에서 서로 연결되어 있는 정보가 주어질 때, 1번 컴퓨터를 통해 웜 바이러스에 걸리게 되는 컴퓨터의 수를 출력하는 프로그램을 작성하시오. 첫째 줄에는 컴퓨터의 수가 주어진다. 컴퓨터의 수는 100 이하이고 각 컴퓨터에는 1번부터 차례대로 번호가 매겨진다. 둘째 줄에는 네트워크 상에서 직접 연결되어 있는 컴퓨터 쌍의 수가 주어진다. 이어서 그 수만큼 한 줄에 한 쌍씩 네트워크 상에서 직접 연결되어 있는 컴퓨터의 번호 쌍이 주어진다. 1번 컴퓨터가 웜 바이러스에 걸렸을 때, 1번 컴퓨터를 통해 웜 바이러스에 걸리게 되는 컴퓨터의 수를 첫째 줄에 출력한다.

#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

int map[101][2] = { 0, }; //컴퓨터의 연결상태를 알 수 있는 2차원배열입니다.
int queue[101] = { 0, }; 
int check[101] = { 0, 1, }; //1은 이미 확인된 값입니다.
int main() {
	int com; //컴퓨터의 개수입니다.
	int net; //네트워크의 연결 개수입니다.
	scanf("%d", &com);
	scanf("%d", &net);
	for (int i = 0; i < net; i++) scanf("%d %d", &map[i][0], &map[i][1]); //네트워크의 연결상태를 map배열에 넣어줍니다.
	
	int a = 0;
	int b = 0;
	queue[a] = 1;
	int vi = 0; //바이러스가 걸린 컴퓨터 개수입니다.
	a++;
	while (a != b) { //a와 b가 같아질 때 까지 반복합니다.
		int c = queue[b]; //변수c에 queue의 b에 위치한 값을 넣습니다.
		b++; //다음 b로 넘어갑니다.
		for (int i = 0; i < net; i++) { //net의 개수만큼 반복해 전부 확인합니다.
			if (c == map[i][0] && check[map[i][1]] == 0) { //만약 c가 map의 시작값과 같고 끝값의 check가 0이면, 
				queue[a] = map[i][1]; //끝값을 queue의 a에 넣고
				check[map[i][1]] = 1; //check가 끝났으니 1로 바꿔줍니다.
				a++; //다음 a로 넘어가고
				vi++; //연결되어있으니 vi를 증가시킵니다.
			}
			if (c == map[i][1] && check[map[i][0]] == 0) { //만약 c가 map의 끝값과 같고 시작값의 check가 0이면,
				queue[a] = map[i][0]; //시작값을 queue의 a에 넣고
				check[map[i][0]] = 1; //check가 끝났으니 1로 바꿔줍니다.
				a++; //다음 a로 넘어가고
				vi++; //연결되어있으니 vi를 증가시킵니다.
			}
		}
	}
	printf("%d\n", vi); //vi의 수를 출력합니다.
	return 0;
}

컴퓨터의 개수와 네트워크 상에서 어떻게 연결되어 있는지 직접 입력하고, 결과적으로 1과 연결되어 있는 컴퓨터의 개수를 출력하는 프로그램입니다.

24-3 <그림 1>과 같이 정사각형 모양의 지도가 있다. 1은 집이 있는 곳을, 0은 집이 없는 곳을 나타낸다. 철수는 이 지도를 가지고 연결된 집의 모임인 단지를 정의하고, 단지에 번호를 붙이려 한다. 여기서 연결되었다는 것은 어떤 집이 좌우, 혹은 아래위로 다른 집이 있는 경우를 말한다. 대각선상에 집이 있는 경우는 연결된 것이 아니다. <그림 2>는 <그림 1>을 단지별로 번호를 붙인 것이다. 지도를 입력하여 단지수를 출력하고, 각 단지에 속하는 집의 수를 오름차순으로 정렬하여 출력하는 프로그램을 작성하시오.
 
첫 번째 줄에는 지도의 크기 N(정사각형이므로 가로와 세로의 크기는 같으며 5≤N≤25)이 입력되고, 그 다음 N줄에는 각각 N개의 자료(0혹은 1)가 입력된다.

#define _CRT_SECURE_NO_WARNINGS

#include<stdio.h>

#define MAX 26

int vectX[4] = { 0, 0, 1, -1 };
int vectY[4] = { 1, -1, 0, 0 };

int map[MAX][MAX]; //최대 지도의 크기
int house_size;
int house_cnt = 0;

// 나올 수 있는 단지의 최대 개수 = n * (n/2) + 1
int house[MAX * (MAX / 2) + 1];

// 버블정렬에서 사용 되는 값 바꾸는 함수
void swap(int* arr, int left, int right) {
    int temp = arr[left];
    arr[left] = arr[right];
    arr[right] = temp;
}

//버블 정렬
void bubble_sort(int* arr) {
    for (int i = 0; i < house_cnt; i++) {
        for (int j = 0; j < house_cnt - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                swap(arr, j, j + 1);
            }
        }
    }
}

void dfs(int x, int y, int key) {
    //key = 단지의 개수
    map[x][y] = key;

    int nextX; int nextY;
    for (int i = 0; i < 4; i++) {
        nextX = x + vectX[i];
        nextY = y + vectY[i];

        if (nextX >= 0 && nextY >= 0 && nextX < house_size && nextY < house_size) {
            // 좌표가 범위 안에 있으며 (x, y) 에서 (nextX, nextY)까지 가는 길이 있는 경우에 dfs함수 호출
            if (map[nextX][nextY] == 1) {
                dfs(nextX, nextY, key);
            }
        }
    }
}

void solution() {
    for (int i = 0; i < house_size; i++) {
        for (int j = 0; j < house_size; j++) {
            if (map[i][j] == 1) {
                house_cnt++;
                dfs(i, j, house_cnt + 1);
            }
        }
    }

    for (int i = 0; i < house_size; i++) {
        for (int j = 0; j < house_size; j++) {
            if (map[i][j] > 1) {
                house[map[i][j] - 2] ++;
            }
        }
    }
}

int main() {
    scanf("%d", &house_size);
    for (int i = 0; i < house_size; i++) {
        for (int j = 0; j < house_size; j++) {
            scanf("%1d", &map[i][j]);
        }
    }

    solution();
    printf("%d\n", house_cnt);
    bubble_sort(house);
    for (int i = 0; i < house_cnt; i++) {
        printf("%d\n", house[i]);
    }
}

house_cnt 변수를 이용하여 단지의 개수를 셈과 동시에 house_cnt값을 부여함에 따라 단지에 있는 집들은 같은 값을 지니게 된다. 각 단지의 집의 수는 버블정렬을 이용해서 오름차순으로 정렬하는 프로그램입니다.

24-4 차세대 영농인 한나는 강원도 고랭지에서 유기농 배추를 재배하기로 하였다. 농약을 쓰지 않고 배추를 재배하려면 배추를 해충으로부터 보호하는 것이 중요하기 때문에, 한나는 해충 방지에 효과적인 배추흰지렁이를 구입하기로 결심한다. 이 지렁이는 배추근처에 서식하며 해충을 잡아 먹음으로써 배추를 보호한다. 특히, 어떤 배추에 배추흰지렁이가 한 마리라도 살고 있으면 이 지렁이는 인접한 다른 배추로 이동할 수 있어, 그 배추들 역시 해충으로부터 보호받을 수 있다.
(한 배추의 상하좌우 네 방향에 다른 배추가 위치한 경우에 서로 인접해있다고 간주한다) 한나가 배추를 재배하는 땅은 고르지 못해서 배추를 군데군데 심어놓았다. 배추들이 모여있는 곳에는 배추흰지렁이가 한 마리만 있으면 되므로 서로 인접해있는 배추들이 몇 군데에 퍼져있는지 조사하면 총 몇 마리의 지렁이가 필요한지 알 수 있다. 예를 들어 배추밭이 아래와 같이 구성되어 있으면 최소 5마리의 배추흰지렁이가 필요하다. (0은 배추가 심어져 있지 않은 땅이고, 1은 배추가 심어져 있는 땅을 나타낸다.) 입력의 첫 줄에는 테스트 케이스의 개수 T가 주어진다. 그 다음 줄부터 각각의 테스트 케이스에 대해 첫째 줄에는 배추를 심은 배추밭의 가로길이 M(1 ≤ M ≤ 50)과 세로길이 N(1 ≤ N ≤ 50), 그리고 배추가 심어져 있는 위치의 개수 K(1 ≤ K ≤ 2500)이 주어진다. 그 다음 K줄에는 배추의 위치 X(0 ≤ X ≤ M-1), Y(0 ≤ Y ≤ N-1)가 주어진다. 각 테스트 케이스에 대해 필요한 최소의 배추흰지렁이 마리 수를 출력한다.

#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#define SIZE 52

int check(int(*arr)[SIZE], int a, int b) {
    if (arr[a][b] == 0) return 0; //배추가 없는 곳에는 지렁이를 놓을 필요가 없으므로 0을 리턴합니다.
    else { //그게 아니라면
        arr[a][b] = 0; //그 자리에 0을 넣고(확인이 끝남)
        if (arr[a - 1][b] == 1) { //왼쪽에 배추가 있으면
            check(arr, a, b - 1); //그 자리에서 재귀해주고
            arr[a - 1][b] = 0; //그 자리에 0을 넣습니다.(확인이 끝남)
        }
        if (arr[a + 1][b] == 1) { //오른쪽에 배추가 있으면
            check(arr, a + 1, b); //그 자리에서 재귀해주고
            arr[a + 1][b] = 0; //그 자리에 0을 넣습니다.(확인이 끝남)
        }
        if (arr[a][b - 1] == 1) { //아래에 배추가 있으면
            check(arr, a, b - 1); //그 자리에서 재귀해주고
            arr[a][b - 1] = 0; //그 자리에 0을 넣습니다.(확인이 끝남)
        }
        if (arr[a][b + 1] == 1) { //위에 배추가 있으면
            check(arr, a, b + 1); //그 자리에서 재귀해주고
            arr[a][b + 1] = 0; //그 자리에 0을 넣습니다.(확인이 끝남)
        }
        return 1; //상하좌우로 움직일 수 있는 범위가 끝나면 그 자리엔 지렁이가 1마리만 있으면 됩니다.
    }
}
int main() {
    int t;
    scanf("%d", &t);
    for (int i = 0; i < t; i++) { //t의 횟수만큼 반복합니다.
        int arr[SIZE][SIZE] = { 0, }; //2차원 배열 arr를 0으로 초기화합니다.
        int m, n, num;
        scanf("%d %d %d", &m, &n, &num); //m은 가로, n은 세로, num은 배추의 수입니다.
        for (int i = 0; i < num; i++) {
            int x, y;
            scanf("%d %d", &x, &y); //배추의 좌표를 입력하고
            arr[y + 1][x + 1] = 1; //배추가 심어져있는것을 표현하기위해 그 위치에 1을 넣습니다.
        }
        int count = 0;
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= m; j++) //반복문을 통해 가로 세로 모두 확인합니다.
                count += check(arr, i, j); //check함수를 통해 지렁이의 수를 count합니다.
        printf("%d\n", count);
    }

}

재귀함수를 통해 상하좌우에 인접한 덩어리의 개수를 세는 프로그램입니다.

24-6 철수의 토마토 농장에서는 토마토를 보관하는 큰 창고를 가지고 있다. 토마토는 아래의 그림과 같이 격자 모양 상자의 칸에 하나씩 넣어서 창고에 보관한다.  창고에 보관되는 토마토들 중에는 잘 익은 것도 있지만, 아직 익지 않은 토마토들도 있을 수 있다. 보관 후 하루가 지나면, 익은 토마토들의 인접한 곳에 있는 익지 않은 토마토들은 익은 토마토의 영향을 받아 익게 된다. 하나의 토마토의 인접한 곳은 왼쪽, 오른쪽, 앞, 뒤 네 방향에 있는 토마토를 의미한다. 대각선 방향에 있는 토마토들에게는 영향을 주지 못하며, 토마토가 혼자 저절로 익는 경우는 없다고 가정한다. 철수는 창고에 보관된 토마토들이 며칠이 지나면 다 익게 되는지, 그 최소 일수를 알고 싶어 한다. 토마토를 창고에 보관하는 격자모양의 상자들의 크기와 익은 토마토들과 익지 않은 토마토들의 정보가 주어졌을 때, 며칠이 지나면 토마토들이 모두 익는지, 그 최소 일수를 구하는 프로그램을 작성하라. 단, 상자의 일부 칸에는 토마토가 들어있지 않을 수도 있다. 첫 줄에는 상자의 크기를 나타내는 두 정수 M,N이 주어진다. M은 상자의 가로 칸의 수, N은 상자의 세로 칸의 수를 나타낸다. 단, 2 ≤ M,N ≤ 1,000 이다. 둘째 줄부터는 하나의 상자에 저장된 토마토들의 정보가 주어진다. 즉, 둘째 줄부터 N개의 줄에는 상자에 담긴 토마토의 정보가 주어진다. 하나의 줄에는 상자 가로줄에 들어있는 토마토의 상태가 M개의 정수로 주어진다. 정수 1은 익은 토마토, 정수 0은 익지 않은 토마토, 정수 -1은 토마토가 들어있지 않은 칸을 나타낸다. 토마토가 하나 이상 있는 경우만 입력으로 주어진다. 여러분은 토마토가 모두 익을 때까지의 최소 날짜를 출력해야 한다. 만약, 저장될 때부터 모든 토마토가 익어있는 상태이면 0을 출력해야 하고, 토마토가 모두 익지는 못하는 상황이면 -1을 출력해야 한다.

#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>
#define MAX 1001

int day = 0;
int map[MAX][MAX];
int queue[MAX][2];
int front = 0;
int rear = 0;
int M, N; 

int x[4] = { 1, 0, -1, 0 }; //상하좌우 탐색을 
int y[4] = { 0, 1, 0, -1 }; //위한 배열입니다.
int sol[MAX][MAX];

void enq(int a, int b) { //queue에 a, b값을 집어넣는 enq함수입니다.
	queue[rear][0] = a;
	queue[rear][1] = b;
	rear++;
}

int check(int a, int b) { //좌표를 받아서 map에 유효한지 검사하는 check함수입니다.
	if (a > N - 1 || b > M - 1 || a < 0 || b < 0) return 0;
	return 1;
}

int main() {
	int i, j;
	scanf("%d %d", &M, &N); //가로, 세로를 입력합니다.
	for (i = 0; i < N; i++)
		for (j = 0; j < M; j++)
			scanf("%d", &map[i][j]); //map에 각각 수를 직접 입력합니다.

	for (i = 0; i < N; i++) 
		for (j = 0; j < M; j++) 
			if (map[i][j] == 1) enq(i, j); //enq함수를 통해 map에 1인 부분 찾습니다.

	while (front < rear) { //front와 rear가 만날 때까지 실행합니다.
		int a = queue[front][0]; //dequeue 실행
		int b = queue[front][1];
		front++; //다음 front로 넘어갑니다.

		for (i = 0; i < 4; i++) { //상하좌우를 순서대로 확인합니다.
			if (map[a + x[i]][b + y[i]] == 0 && check(a + x[i], b + y[i]) == 1) {
				//만약 map[a][b]의 상하좌우 값이 0이고, check함수를 통해 좌표가 map에서 유효하면
				map[a + x[i]][b + y[i]] = 1; //map[a][b]의 상하좌우 중 한 곳에 1을 넣고,
				enq(a + x[i], b + y[i]); //그 위치를 enq합니다.
				sol[a + x[i]][b + y[i]] = sol[a][b] + 1; //그 위치에서 sol값에 1을 더해 상하좌우에 넣습니다.
			}
		}
	}

	int flag = 0;
	for (i = 0; i < N; i++) {
		for (j = 0; j < M; j++) {
			if (map[i][j] == 0) flag = 1; 
			//만약 map에 0이 남아있다면 토마토가 모두 익지 못하는 상황입니다.
			if (day < sol[i][j]) day = sol[i][j]; //day값이 sol에서의 값보다 작다면 그 값을 day에 넣어줍니다.
		}
	}

	if (flag == 1) printf("-1\n"); //만약 토마토가 모두 익지 못하는 상황이면 -1을 출력하고
	else printf("%d\n", day); //아니라면 총 걸리는 날짜 day를 출력합니다.
	return 0;
}

queue의 특징을 이용해 토마토가 모두 익는데까지 걸리는 날을 계산하는 프로그램입니다.

